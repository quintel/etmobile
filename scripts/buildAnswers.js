/* eslint no-console: 0 */
/* eslint no-param-reassign: 0 */
/* eslint import/no-extraneous-dependencies: 0 */

import axios from 'axios';
import fs from 'fs';
import process from 'process';
import dotenv from 'dotenv';

import staticChoices from '../src/data/choices';

dotenv.config({ silent: true });

const endpoint = process.env.REACT_APP_ETENGINE_URL;

if (!endpoint) {
  console.error('No REACT_APP_ETENGINE_URL defined; do you have a .env file?');
  process.exit(1);
}

/**
 * Template string tag which removes leading space from each line in the string.
 * Does not strip space from interpolated values.
 *
 * @return string
 */
const stripLeadingSpace = (strings, ...values) => {
  const strip = str => str.split('\n').map(line => line.trim()).join('\n');

  // Interweave the strings with the
  // substitution vars first.
  let output = '';

  for (let i = 0; i < values.length; i += 1) {
    output += `${strip(strings[i])} ${values[i]}`;
  }

  output += `${strings[values.length].trim()}\n`;

  return output.trimLeft();
};

/**
 * Writes the query results received from ETEngine for each choice to the given
 * path.
 *
 * @param  {string]} path    Path to the file to be written
 * @param  {array}   results Array of results for each choice

 * @return null Returns nothing.
 */
const writeResults = (path, results) => {
  fs.writeFile(
    path,
    stripLeadingSpace`
      // This file is automatically generated by 'scripts/buildAnswers.js. Do not make
      // changes directly to this file as they will be overwritten the next time the
      // script is run.

      export default ${JSON.stringify(results, null, 2)};
    `,
    err => console.log(err || `\nThe file was saved: ${path}`)
  );
};

/**
 * Creates a new ETEngine scenario.
 * @return {Promise} Returns the Axios promise for the HTTP request.
 */
const createScenario = () => (
  axios.post(`${endpoint}/api/v3/scenarios`, {
    scenario: {
      area_code: 'nl',
      end_year: 2050,
      source: 'ETMobile Choice Builder'
    }
  })
);

/**
 * Resets the scenario at URL and applies the given inputs.
 *
 * @param  {string} url    URL of the scenario.
 * @param  {object} inputs Object containing input values to be saved.
 *
 * @return {Promise}       The Axios promise for the HTTP request.
 */
const fetchResults = (url, inputs) => (
  axios.put(url, {
    reset: true,
    scenario: { user_values: inputs },
    gqueries: ['total_co2_emissions']
  })
);

/**
 * Requests Gquery results for each choice. Reuses the scenario at url
 * performing each request in serial.
 *
 * @param  {number} baseline Future CO2 emissions in the default scenario.
 * @param  {array} results   Array in which results are stored.
 * @param  {array} requests  Array of requests to be performed.
 * @param  {number} index    Index of the request to be performed.
 * @param  {string} url      URL of the ETEngine scenario.
 *
 * @return {Promise} Returns a promise which is resolved when all requests have
 *                   completed.
 */
const serialFetchResults = (baseline, results, requests, index, url) => {
  const { index: cIndex, inputs, name } = requests[index];


  process.stdout.write(`${name} `);

  return fetchResults(url, inputs)
    .then((response) => {
      const co2 = response.data.gqueries.total_co2_emissions.future;
      const delta = parseFloat((-(1 - (co2 / baseline)) * 100).toFixed(4));

      results[cIndex] = delta;

      console.log(`= ${delta}%`);

      if (requests[index + 1]) {
        return serialFetchResults(baseline, results, requests, index + 1, url);
      }

      return results;
    });
};

/**
 * Converts the map of choices to an array of requests which need to be
 * performed.
 */
const choicesToRequests = (choices) => {
  const requests = [];

  choices.forEach(({ name, inputs }, index) => {
    requests.push({ index, inputs, name });
  });

  return requests;
};

console.log('Fetching answers from', endpoint);

createScenario().then((response) => {
  axios
    .put(response.data.url, { reset: true, gqueries: ['total_co2_emissions'] })
    .then(({ data: { gqueries } }) => {
      const fetchPromise = serialFetchResults(
        gqueries.total_co2_emissions.future,
        [],
        choicesToRequests(staticChoices),
        0,
        response.data.url
      );

      fetchPromise
        .then(results => writeResults('src/data/answers.js', results))
        .catch(err => console.error(err));
    });
});
