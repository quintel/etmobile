/* eslint no-console: 0 */
/* eslint no-param-reassign: 0 */

// eslint-disable-next-line import/no-extraneous-dependencies
import axios from 'axios';
import fs from 'fs';

import questions from '../src/data/questions';

// const axios = require('axios');
// const fs = require('fs');
// const questions = require('../src/data/questions');

// const endpoint = 'https://beta-engine.energytransitionmodel.com';
const endpoint = 'http://etengine.dev';

/**
 * Template string tag which removes leading space from each line in the string.
 * Does not strip space from interpolated values.
 *
 * @return string
 */
const stripLeadingSpace = (strings, ...values) => {
  const strip = str => str.split('\n').map(line => line.trim()).join('\n');

  // Interweave the strings with the
  // substitution vars first.
  let output = '';

  for (let i = 0; i < values.length; i += 1) {
    output += `${strip(strings[i])} ${values[i]}`;
  }

  output += `${strings[values.length].trim()}\n`;

  return output.trimLeft();
};

/**
 * Writes the query results received from ETEngine for each choice to the given
 * path.
 *
 * @param  {string]} path    Path to the file to be written
 * @param  {array}   results Array of results for each choice

 * @return null Returns nothing.
 */
const writeResults = (path, results) => {
  fs.writeFile(
    path,
    stripLeadingSpace`
      // This file is automatically generated by 'scripts/buildAnswers.js. Do not make
      // changes directly to this file as they will be overwritten the next time the
      // script is run.

      export default ${JSON.stringify(results, null, 2)};
    `,
    err => console.log(err || `\nThe file was saved: ${path}`)
  );
};

/**
 * Creates a new ETEngine scenario.
 * @return {Promise} Returns the Axios promise for the HTTP request.
 */
const createScenario = () => (
  axios.post(`${endpoint}/api/v3/scenarios`, {
    scenario: {
      area_code: 'nl',
      end_year: 2050,
      source: 'ETMobile Choice Builder'
    }
  })
);

/**
 * Resets the scenario at URL and applies the given inputs.
 *
 * @param  {string} url    URL of the scenario.
 * @param  {object} inputs Object containing input values to be saved.
 *
 * @return {Promise}       The Axios promise for the HTTP request.
 */
const fetchResults = (url, inputs) => (
  axios.put(url, {
    reset: true,
    scenario: { user_values: inputs },
    gqueries: ['total_co2_emissions']
  })
);

/**
 * Requests Gquery results for each choice. Reuses the scenario at url
 * performing each request in serial.
 *
 * @param  {number} baseline Future CO2 emissions in the default scenario.
 * @param  {[type]} results  Array in which results are stored.
 * @param  {[type]} requests Array of requests to be performed.
 * @param  {[type]} index    Index of the request to be performed.
 * @param  {[type]} url      URL of the ETEngine scenario.
 *
 * @return {Promise} Returns a promise which is resolved when all requests have
 *                   completed.
 */
const serialFetchResults = (baseline, results, requests, index, url) => {
  const { qIndex, inputs, qName, cName } = requests[index];


  if (!results[qIndex]) {
    console.log('');
    console.log(qName);
  }

  process.stdout.write(`  - ${cName}`);

  return fetchResults(url, inputs)
    .then((response) => {
      const co2 = response.data.gqueries.total_co2_emissions.future;
      const delta = parseFloat((-(1 - (co2 / baseline)) * 100).toFixed(4));

      if (results[qIndex]) {
        results[qIndex].push(delta);
      } else {
        results[qIndex] = [delta];
      }

      console.log(` = ${delta}%`);

      if (requests[index + 1]) {
        return serialFetchResults(baseline, results, requests, index + 1, url);
      }

      return results;
    });
};

/**
 * Converts the map of questions and choices to an array of requests which need
 * to be performed.
 */
const questionsToRequests = (qs) => {
  const requests = [];

  qs.forEach((question, qIndex) => {
    question.choices.forEach((choice) => {
      requests.push({
        qIndex,
        inputs: choice.inputs,
        qName: question.name,
        cName: choice.name
      });
    });
  });

  return requests;
};

console.log('Fetching answers from', endpoint);

createScenario().then((response) => {
  axios
    .put(response.data.url, { reset: true, gqueries: ['total_co2_emissions'] })
    .then(({ data: { gqueries } }) => {
      const fetchPromise = serialFetchResults(
        gqueries.total_co2_emissions.future,
        [],
        questionsToRequests(questions),
        0,
        response.data.url
      );

      fetchPromise
        .then(results => writeResults('src/data/answers.js', results))
        .catch(err => console.error(err));
    });
});
